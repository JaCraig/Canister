{
  "api/Canister.Interfaces.ICanisterConfiguration.html": {
    "href": "api/Canister.Interfaces.ICanisterConfiguration.html",
    "title": "Interface ICanisterConfiguration | Canister API Reference",
    "summary": "Interface ICanisterConfiguration Namespace Canister.Interfaces Assembly Canister.IoC.dll Defines the contract for configuring Canister by specifying which assemblies to include for dependency injection and service registration. public interface ICanisterConfiguration Methods AddAssembly(IEnumerable<Assembly?>?) Adds a collection of assemblies to the Canister configuration for scanning and registration. ICanisterConfiguration AddAssembly(IEnumerable<Assembly?>? assemblies) Parameters assemblies IEnumerable<Assembly> An IEnumerable<T> containing assemblies to add. Returns ICanisterConfiguration The current ICanisterConfiguration instance for chaining. AddAssembly(params Assembly?[]?) Adds one or more assemblies to the Canister configuration for scanning and registration. ICanisterConfiguration AddAssembly(params Assembly?[]? assemblies) Parameters assemblies Assembly[] An array of Assembly instances to add. Returns ICanisterConfiguration The current ICanisterConfiguration instance for chaining. AddDefaultAssemblies() Adds the default assemblies, typically including the entry assembly and its referenced assemblies, to the Canister configuration for scanning and registration. ICanisterConfiguration AddDefaultAssemblies() Returns ICanisterConfiguration The current ICanisterConfiguration instance for chaining. UseLogger(ILogger?, LogLevel) Sets the logger and log level for diagnostics and logging in a fluent manner. ICanisterConfiguration UseLogger(ILogger? logger, LogLevel logLevel = LogLevel.Information) Parameters logger ILogger The logger to use. logLevel LogLevel The minimum log level (default: Information). Returns ICanisterConfiguration The current ICanisterConfiguration instance for chaining."
  },
  "api/Canister.Interfaces.IModule.html": {
    "href": "api/Canister.Interfaces.IModule.html",
    "title": "Interface IModule | Canister API Reference",
    "summary": "Interface IModule Namespace Canister.Interfaces Assembly Canister.IoC.dll Represents a module that can be loaded into the IoC container. Implementations define service registrations and their order. public interface IModule Properties Order Gets the order in which this module should be loaded. Modules with lower order values are loaded first. int Order { get; } Property Value int Methods Load(IServiceCollection) Loads the module and registers its services with the specified IServiceCollection. void Load(IServiceCollection serviceDescriptors) Parameters serviceDescriptors IServiceCollection The IServiceCollection to which services should be registered."
  },
  "api/Canister.Interfaces.html": {
    "href": "api/Canister.Interfaces.html",
    "title": "Namespace Canister.Interfaces | Canister API Reference",
    "summary": "Namespace Canister.Interfaces Interfaces ICanisterConfiguration Defines the contract for configuring Canister by specifying which assemblies to include for dependency injection and service registration. IModule Represents a module that can be loaded into the IoC container. Implementations define service registrations and their order."
  },
  "api/Canister.IoC.Attributes.RegisterAllAttribute.html": {
    "href": "api/Canister.IoC.Attributes.RegisterAllAttribute.html",
    "title": "Class RegisterAllAttribute | Canister API Reference",
    "summary": "Class RegisterAllAttribute Namespace Canister.IoC.Attributes Assembly Canister.IoC.dll This attribute is used to register all items of a specific type with Canister and is used to mark a type for registration. [AttributeUsage(AttributeTargets.Interface, AllowMultiple = false)] public class RegisterAllAttribute : Attribute Inheritance object Attribute RegisterAllAttribute Inherited Members Attribute.Equals(object) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetHashCode() Attribute.IsDefaultAttribute() Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.Match(object) Attribute.TypeId object.Equals(object, object) object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors RegisterAllAttribute() Constructor public RegisterAllAttribute() RegisterAllAttribute(ServiceLifetime) Constructor public RegisterAllAttribute(ServiceLifetime lifetime) Parameters lifetime ServiceLifetime Lifetime of the service Properties Lifetime The lifetime of the service. public ServiceLifetime Lifetime { get; set; } Property Value ServiceLifetime"
  },
  "api/Canister.IoC.Attributes.RegisterAttribute.html": {
    "href": "api/Canister.IoC.Attributes.RegisterAttribute.html",
    "title": "Class RegisterAttribute | Canister API Reference",
    "summary": "Class RegisterAttribute Namespace Canister.IoC.Attributes Assembly Canister.IoC.dll This attribute is used to register a type with Canister and is used to mark a type for registration. [AttributeUsage(AttributeTargets.Class|AttributeTargets.Struct, AllowMultiple = false)] public class RegisterAttribute : Attribute Inheritance object Attribute RegisterAttribute Inherited Members Attribute.Equals(object) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetHashCode() Attribute.IsDefaultAttribute() Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.Match(object) Attribute.TypeId object.Equals(object, object) object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors RegisterAttribute() Constructor public RegisterAttribute() RegisterAttribute(ServiceLifetime, object?) Constructor public RegisterAttribute(ServiceLifetime lifetime, object? serviceKey = null) Parameters lifetime ServiceLifetime Lifetime of the service serviceKey object The service key to register as (if any) Properties Lifetime The lifetime of the service. public ServiceLifetime Lifetime { get; set; } Property Value ServiceLifetime ServiceKey The service key to register as (if any). public object? ServiceKey { get; set; } Property Value object"
  },
  "api/Canister.IoC.Attributes.html": {
    "href": "api/Canister.IoC.Attributes.html",
    "title": "Namespace Canister.IoC.Attributes | Canister API Reference",
    "summary": "Namespace Canister.IoC.Attributes Classes RegisterAllAttribute This attribute is used to register all items of a specific type with Canister and is used to mark a type for registration. RegisterAttribute This attribute is used to register a type with Canister and is used to mark a type for registration."
  },
  "api/Canister.IoC.ExtensionMethods.HashSetExtensions.html": {
    "href": "api/Canister.IoC.ExtensionMethods.HashSetExtensions.html",
    "title": "Class HashSetExtensions | Canister API Reference",
    "summary": "Class HashSetExtensions Namespace Canister.IoC.ExtensionMethods Assembly Canister.IoC.dll Provides extension methods for HashSet<T> of Type to filter available classes and interfaces. public static class HashSetExtensions Inheritance object HashSetExtensions Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods GetAvailableClasses(HashSet<Type>) Returns an array of non-abstract, non-generic classes from the given HashSet<T>. public static Type[] GetAvailableClasses(this HashSet<Type> types) Parameters types HashSet<Type> The set of types to filter. Returns Type[] An array of Type objects that are concrete classes (not abstract, not generic). Returns an empty array if types is null or empty. GetAvailableInterfaces(HashSet<Type>) Returns an array of non-generic interfaces from the given HashSet<T>. public static Type[] GetAvailableInterfaces(this HashSet<Type> types) Parameters types HashSet<Type> The set of types to filter. Returns Type[] An array of Type objects that are interfaces and not generic. Returns an empty array if types is null or empty."
  },
  "api/Canister.IoC.ExtensionMethods.html": {
    "href": "api/Canister.IoC.ExtensionMethods.html",
    "title": "Namespace Canister.IoC.ExtensionMethods | Canister API Reference",
    "summary": "Namespace Canister.IoC.ExtensionMethods Classes HashSetExtensions Provides extension methods for HashSet<T> of Type to filter available classes and interfaces."
  },
  "api/Canister.IoC.Modules.DefaultModule.html": {
    "href": "api/Canister.IoC.Modules.DefaultModule.html",
    "title": "Class DefaultModule | Canister API Reference",
    "summary": "Class DefaultModule Namespace Canister.IoC.Modules Assembly Canister.IoC.dll Default module public class DefaultModule : IModule Inheritance object DefaultModule Implements IModule Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Properties Order Order to run this in public int Order { get; } Property Value int Methods Load(IServiceCollection) Loads the module using the bootstrapper public void Load(IServiceCollection serviceDescriptors) Parameters serviceDescriptors IServiceCollection The service descriptors. See Also IModule"
  },
  "api/Canister.IoC.Modules.html": {
    "href": "api/Canister.IoC.Modules.html",
    "title": "Namespace Canister.IoC.Modules | Canister API Reference",
    "summary": "Namespace Canister.IoC.Modules Classes DefaultModule Default module"
  },
  "api/Microsoft.Extensions.DependencyInjection.ServiceCollectionDecoratorExtensions.html": {
    "href": "api/Microsoft.Extensions.DependencyInjection.ServiceCollectionDecoratorExtensions.html",
    "title": "Class ServiceCollectionDecoratorExtensions | Canister API Reference",
    "summary": "Class ServiceCollectionDecoratorExtensions Namespace Microsoft.Extensions.DependencyInjection Assembly Canister.IoC.dll Provides extension methods for decorating registered services. public static class ServiceCollectionDecoratorExtensions Inheritance object ServiceCollectionDecoratorExtensions Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods Decorate<TService, TDecorator>(IServiceCollection?) Decorates all registrations of TService with TDecorator. The decorator must have a constructor that takes TService as a parameter. public static IServiceCollection? Decorate<TService, TDecorator>(this IServiceCollection? services) where TService : class where TDecorator : class, TService Parameters services IServiceCollection The service collection. Returns IServiceCollection The service collection for chaining. Type Parameters TService The service type to decorate. TDecorator The decorator type (must implement TService)."
  },
  "api/Microsoft.Extensions.DependencyInjection.ServiceCollectionDiagnosticsExtensions.html": {
    "href": "api/Microsoft.Extensions.DependencyInjection.ServiceCollectionDiagnosticsExtensions.html",
    "title": "Class ServiceCollectionDiagnosticsExtensions | Canister API Reference",
    "summary": "Class ServiceCollectionDiagnosticsExtensions Namespace Microsoft.Extensions.DependencyInjection Assembly Canister.IoC.dll Provides diagnostic and debugging extension methods for IServiceCollection. public static class ServiceCollectionDiagnosticsExtensions Inheritance object ServiceCollectionDiagnosticsExtensions Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods GetRegistrationsSummary(IServiceCollection) Returns a summary of all service registrations in the IServiceCollection. public static string GetRegistrationsSummary(this IServiceCollection services) Parameters services IServiceCollection The service collection. Returns string A formatted string listing all service registrations. LogRegistrations(IServiceCollection, ILogger, LogLevel) Logs all service registrations in the IServiceCollection to the provided logger. public static void LogRegistrations(this IServiceCollection services, ILogger logger, LogLevel level = LogLevel.Information) Parameters services IServiceCollection The service collection. logger ILogger The logger to use. level LogLevel The log level (default: Information)."
  },
  "api/Microsoft.Extensions.DependencyInjection.ServiceCollectionExtensions.html": {
    "href": "api/Microsoft.Extensions.DependencyInjection.ServiceCollectionExtensions.html",
    "title": "Class ServiceCollectionExtensions | Canister API Reference",
    "summary": "Class ServiceCollectionExtensions Namespace Microsoft.Extensions.DependencyInjection Assembly Canister.IoC.dll Extension methods for IServiceCollection to check for the existence of services. public static class ServiceCollectionExtensions Inheritance object ServiceCollectionExtensions Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods AddAllScoped(IServiceCollection?, Type) Registers all objects of a certain type with the service collection as scoped. public static IServiceCollection? AddAllScoped(this IServiceCollection? serviceDescriptors, Type registerType) Parameters serviceDescriptors IServiceCollection The service collection to add the services to. registerType Type The type to register. Returns IServiceCollection The updated service collection. AddAllScoped<T>(IServiceCollection?) Registers all objects of a certain type with the service collection as scoped. public static IServiceCollection? AddAllScoped<T>(this IServiceCollection? serviceDescriptors) Parameters serviceDescriptors IServiceCollection The service collection to add the services to. Returns IServiceCollection The updated service collection. Type Parameters T The object type to register. AddAllSingleton(IServiceCollection?, Type) Registers all objects of a certain type with the service collection as Singleton. public static IServiceCollection? AddAllSingleton(this IServiceCollection? serviceDescriptors, Type registerType) Parameters serviceDescriptors IServiceCollection The service collection to add the services to. registerType Type The type to register. Returns IServiceCollection The updated service collection. AddAllSingleton<T>(IServiceCollection?) Registers all objects of a certain type with the service collection as Singleton. public static IServiceCollection? AddAllSingleton<T>(this IServiceCollection? serviceDescriptors) Parameters serviceDescriptors IServiceCollection The service collection to add the services to. Returns IServiceCollection The updated service collection. Type Parameters T The object type to register. AddAllTransient(IServiceCollection?, Type) Registers all objects of a certain type with the service collection as Transient. public static IServiceCollection? AddAllTransient(this IServiceCollection? serviceDescriptors, Type registerType) Parameters serviceDescriptors IServiceCollection The service collection to add the services to. registerType Type The type to register. Returns IServiceCollection The updated service collection. AddAllTransient<T>(IServiceCollection?) Registers all objects of a certain type with the service collection as Transient. public static IServiceCollection? AddAllTransient<T>(this IServiceCollection? serviceDescriptors) Parameters serviceDescriptors IServiceCollection The service collection to add the services to. Returns IServiceCollection The updated service collection. Type Parameters T The object type to register. AddCanisterModules(IServiceCollection?, Action<ICanisterConfiguration>?) Finds the Canister modules and loads them into the service collection using a configuration action. public static IServiceCollection? AddCanisterModules(this IServiceCollection? serviceDescriptors, Action<ICanisterConfiguration>? configure = null) Parameters serviceDescriptors IServiceCollection The service descriptors. configure Action<ICanisterConfiguration> The configuration action to specify which assemblies to load the modules from. Returns IServiceCollection The service collection with Canister modules loaded. AddCanisterModules(IServiceCollection?, params Assembly[]) Finds the Canister modules and loads them into the service collection using the specified assemblies. public static IServiceCollection? AddCanisterModules(this IServiceCollection? serviceDescriptors, params Assembly[] assemblies) Parameters serviceDescriptors IServiceCollection The service descriptors. assemblies Assembly[] Assemblies to scan for modules and registrations. Returns IServiceCollection The service collection with Canister modules loaded. AddKeyedScopedIf(IServiceCollection?, Func<IServiceCollection, bool>, Type, object?) Adds a scoped service of the specified type with an implementation of the specified type to the service collection if the predicate is true. public static IServiceCollection? AddKeyedScopedIf(this IServiceCollection? serviceDescriptors, Func<IServiceCollection, bool> predicate, Type serviceType, object? serviceKey) Parameters serviceDescriptors IServiceCollection The service collection to add the service to. predicate Func<IServiceCollection, bool> A predicate to determine if the service should be added. serviceType Type The service type to register. serviceKey object The key for the service registration. Returns IServiceCollection The updated service collection. AddKeyedScopedIf(IServiceCollection?, Func<IServiceCollection, bool>, Type, object?, Func<IServiceProvider, object?, object>) Adds a scoped service of the specified type with an implementation factory to the service collection if the predicate is true. public static IServiceCollection? AddKeyedScopedIf(this IServiceCollection? serviceDescriptors, Func<IServiceCollection, bool> predicate, Type serviceType, object? serviceKey, Func<IServiceProvider, object?, object> implementationFactory) Parameters serviceDescriptors IServiceCollection The service collection to add the service to. predicate Func<IServiceCollection, bool> A predicate to determine if the service should be added. serviceType Type The service type to register. serviceKey object The key for the service registration. implementationFactory Func<IServiceProvider, object, object> The factory to create the implementation. Returns IServiceCollection The updated service collection. AddKeyedScopedIf(IServiceCollection?, Func<IServiceCollection, bool>, Type, object?, Type) Adds a scoped service with a specified key to the service collection if the given predicate evaluates to true. public static IServiceCollection? AddKeyedScopedIf(this IServiceCollection? serviceDescriptors, Func<IServiceCollection, bool> predicate, Type serviceType, object? serviceKey, Type implementationType) Parameters serviceDescriptors IServiceCollection The IServiceCollection to which the service will be added. predicate Func<IServiceCollection, bool> A function that determines whether the service should be added. The service is added only if this function returns true. serviceType Type The type of the service to register. serviceKey object An optional key used to distinguish this service registration from others of the same type. implementationType Type The type that implements the service. Returns IServiceCollection The updated IServiceCollection if the service was added; otherwise, the original IServiceCollection. AddKeyedScopedIf<TService>(IServiceCollection?, Func<IServiceCollection, bool>, object?) Adds a scoped service of the specified type to the service collection if the predicate is true. public static IServiceCollection? AddKeyedScopedIf<TService>(this IServiceCollection? serviceDescriptors, Func<IServiceCollection, bool> predicate, object? serviceKey) where TService : class Parameters serviceDescriptors IServiceCollection The service collection to add the service to. predicate Func<IServiceCollection, bool> A predicate to determine if the service should be added. serviceKey object The key for the service registration. Returns IServiceCollection The updated service collection. Type Parameters TService The service type to register. AddKeyedScopedIf<TService>(IServiceCollection?, Func<IServiceCollection, bool>, object?, Func<IServiceProvider, object?, TService>) Adds a scoped service of the specified type with a factory specified in implementationFactory to the service collection if the predicate is true. public static IServiceCollection? AddKeyedScopedIf<TService>(this IServiceCollection? serviceDescriptors, Func<IServiceCollection, bool> predicate, object? serviceKey, Func<IServiceProvider, object?, TService> implementationFactory) where TService : class Parameters serviceDescriptors IServiceCollection The service collection to add the service to. predicate Func<IServiceCollection, bool> A predicate to determine if the service should be added. serviceKey object The key for the service registration. implementationFactory Func<IServiceProvider, object, TService> The factory to create the implementation. Returns IServiceCollection The updated service collection. Type Parameters TService The service type to register. AddKeyedScopedIf<TService, TImplementation>(IServiceCollection?, Func<IServiceCollection, bool>, object?) Adds a scoped service of the specified type with an implementation type to the service collection if the predicate is true. public static IServiceCollection? AddKeyedScopedIf<TService, TImplementation>(this IServiceCollection? serviceDescriptors, Func<IServiceCollection, bool> predicate, object? serviceKey) where TService : class where TImplementation : class, TService Parameters serviceDescriptors IServiceCollection The service collection to add the service to. predicate Func<IServiceCollection, bool> A predicate to determine if the service should be added. serviceKey object The key for the service registration. Returns IServiceCollection The updated service collection. Type Parameters TService The service type to register. TImplementation The implementation type to use. AddKeyedScopedIf<TService, TImplementation>(IServiceCollection?, Func<IServiceCollection, bool>, object?, Func<IServiceProvider, object?, TImplementation>) Adds a scoped service of the specified type with an implementation factory to the service collection if the predicate is true. public static IServiceCollection? AddKeyedScopedIf<TService, TImplementation>(this IServiceCollection? serviceDescriptors, Func<IServiceCollection, bool> predicate, object? serviceKey, Func<IServiceProvider, object?, TImplementation> implementationFactory) where TService : class where TImplementation : class, TService Parameters serviceDescriptors IServiceCollection The service collection to add the service to. predicate Func<IServiceCollection, bool> A predicate to determine if the service should be added. serviceKey object The key for the service registration. implementationFactory Func<IServiceProvider, object, TImplementation> The factory to create the implementation. Returns IServiceCollection The updated service collection. Type Parameters TService The service type to register. TImplementation The implementation type to use. AddKeyedSingletonIf(IServiceCollection?, Func<IServiceCollection, bool>, Type, object?) Adds a Singleton service of the specified type with an implementation of the specified type to the service collection if the predicate is true. public static IServiceCollection? AddKeyedSingletonIf(this IServiceCollection? serviceDescriptors, Func<IServiceCollection, bool> predicate, Type serviceType, object? serviceKey) Parameters serviceDescriptors IServiceCollection The service collection to add the service to. predicate Func<IServiceCollection, bool> A predicate to determine if the service should be added. serviceType Type The service type to register. serviceKey object The key for the service registration. Returns IServiceCollection The updated service collection. AddKeyedSingletonIf(IServiceCollection?, Func<IServiceCollection, bool>, Type, object?, Func<IServiceProvider, object?, object>) Adds a Singleton service of the specified type with an implementation factory to the service collection if the predicate is true. public static IServiceCollection? AddKeyedSingletonIf(this IServiceCollection? serviceDescriptors, Func<IServiceCollection, bool> predicate, Type serviceType, object? serviceKey, Func<IServiceProvider, object?, object> implementationFactory) Parameters serviceDescriptors IServiceCollection The service collection to add the service to. predicate Func<IServiceCollection, bool> A predicate to determine if the service should be added. serviceType Type The service type to register. serviceKey object The key for the service registration. implementationFactory Func<IServiceProvider, object, object> The factory to create the implementation. Returns IServiceCollection The updated service collection. AddKeyedSingletonIf(IServiceCollection?, Func<IServiceCollection, bool>, Type, object?, Type) Adds a Singleton service with a specified key to the service collection if the given predicate evaluates to true. public static IServiceCollection? AddKeyedSingletonIf(this IServiceCollection? serviceDescriptors, Func<IServiceCollection, bool> predicate, Type serviceType, object? serviceKey, Type implementationType) Parameters serviceDescriptors IServiceCollection The IServiceCollection to which the service will be added. predicate Func<IServiceCollection, bool> A function that determines whether the service should be added. The service is added only if this function returns true. serviceType Type The type of the service to register. serviceKey object An optional key used to distinguish this service registration from others of the same type. implementationType Type The type that implements the service. Returns IServiceCollection The updated IServiceCollection if the service was added; otherwise, the original IServiceCollection. AddKeyedSingletonIf<TService>(IServiceCollection?, Func<IServiceCollection, bool>, object?) Adds a Singleton service of the specified type to the service collection if the predicate is true. public static IServiceCollection? AddKeyedSingletonIf<TService>(this IServiceCollection? serviceDescriptors, Func<IServiceCollection, bool> predicate, object? serviceKey) where TService : class Parameters serviceDescriptors IServiceCollection The service collection to add the service to. predicate Func<IServiceCollection, bool> A predicate to determine if the service should be added. serviceKey object The key for the service registration. Returns IServiceCollection The updated service collection. Type Parameters TService The service type to register. AddKeyedSingletonIf<TService>(IServiceCollection?, Func<IServiceCollection, bool>, object?, Func<IServiceProvider, object?, TService>) Adds a Singleton service of the specified type with a factory specified in implementationFactory to the service collection if the predicate is true. public static IServiceCollection? AddKeyedSingletonIf<TService>(this IServiceCollection? serviceDescriptors, Func<IServiceCollection, bool> predicate, object? serviceKey, Func<IServiceProvider, object?, TService> implementationFactory) where TService : class Parameters serviceDescriptors IServiceCollection The service collection to add the service to. predicate Func<IServiceCollection, bool> A predicate to determine if the service should be added. serviceKey object The key for the service registration. implementationFactory Func<IServiceProvider, object, TService> The factory to create the implementation. Returns IServiceCollection The updated service collection. Type Parameters TService The service type to register. AddKeyedSingletonIf<TService, TImplementation>(IServiceCollection?, Func<IServiceCollection, bool>, object?) Adds a Singleton service of the specified type with an implementation type to the service collection if the predicate is true. public static IServiceCollection? AddKeyedSingletonIf<TService, TImplementation>(this IServiceCollection? serviceDescriptors, Func<IServiceCollection, bool> predicate, object? serviceKey) where TService : class where TImplementation : class, TService Parameters serviceDescriptors IServiceCollection The service collection to add the service to. predicate Func<IServiceCollection, bool> A predicate to determine if the service should be added. serviceKey object The key for the service registration. Returns IServiceCollection The updated service collection. Type Parameters TService The service type to register. TImplementation The implementation type to use. AddKeyedSingletonIf<TService, TImplementation>(IServiceCollection?, Func<IServiceCollection, bool>, object?, Func<IServiceProvider, object?, TImplementation>) Adds a Singleton service of the specified type with an implementation factory to the service collection if the predicate is true. public static IServiceCollection? AddKeyedSingletonIf<TService, TImplementation>(this IServiceCollection? serviceDescriptors, Func<IServiceCollection, bool> predicate, object? serviceKey, Func<IServiceProvider, object?, TImplementation> implementationFactory) where TService : class where TImplementation : class, TService Parameters serviceDescriptors IServiceCollection The service collection to add the service to. predicate Func<IServiceCollection, bool> A predicate to determine if the service should be added. serviceKey object The key for the service registration. implementationFactory Func<IServiceProvider, object, TImplementation> The factory to create the implementation. Returns IServiceCollection The updated service collection. Type Parameters TService The service type to register. TImplementation The implementation type to use. AddKeyedTransientIf(IServiceCollection?, Func<IServiceCollection, bool>, Type, object?) Adds a Transient service of the specified type with an implementation of the specified type to the service collection if the predicate is true. public static IServiceCollection? AddKeyedTransientIf(this IServiceCollection? serviceDescriptors, Func<IServiceCollection, bool> predicate, Type serviceType, object? serviceKey) Parameters serviceDescriptors IServiceCollection The service collection to add the service to. predicate Func<IServiceCollection, bool> A predicate to determine if the service should be added. serviceType Type The service type to register. serviceKey object The key for the service registration. Returns IServiceCollection The updated service collection. AddKeyedTransientIf(IServiceCollection?, Func<IServiceCollection, bool>, Type, object?, Func<IServiceProvider, object?, object>) Adds a Transient service of the specified type with an implementation factory to the service collection if the predicate is true. public static IServiceCollection? AddKeyedTransientIf(this IServiceCollection? serviceDescriptors, Func<IServiceCollection, bool> predicate, Type serviceType, object? serviceKey, Func<IServiceProvider, object?, object> implementationFactory) Parameters serviceDescriptors IServiceCollection The service collection to add the service to. predicate Func<IServiceCollection, bool> A predicate to determine if the service should be added. serviceType Type The service type to register. serviceKey object The key for the service registration. implementationFactory Func<IServiceProvider, object, object> The factory to create the implementation. Returns IServiceCollection The updated service collection. AddKeyedTransientIf(IServiceCollection?, Func<IServiceCollection, bool>, Type, object?, Type) Adds a Transient service with a specified key to the service collection if the given predicate evaluates to true. public static IServiceCollection? AddKeyedTransientIf(this IServiceCollection? serviceDescriptors, Func<IServiceCollection, bool> predicate, Type serviceType, object? serviceKey, Type implementationType) Parameters serviceDescriptors IServiceCollection The IServiceCollection to which the service will be added. predicate Func<IServiceCollection, bool> A function that determines whether the service should be added. The service is added only if this function returns true. serviceType Type The type of the service to register. serviceKey object An optional key used to distinguish this service registration from others of the same type. implementationType Type The type that implements the service. Returns IServiceCollection The updated IServiceCollection if the service was added; otherwise, the original IServiceCollection. AddKeyedTransientIf<TService>(IServiceCollection?, Func<IServiceCollection, bool>, object?) Adds a Transient service of the specified type to the service collection if the predicate is true. public static IServiceCollection? AddKeyedTransientIf<TService>(this IServiceCollection? serviceDescriptors, Func<IServiceCollection, bool> predicate, object? serviceKey) where TService : class Parameters serviceDescriptors IServiceCollection The service collection to add the service to. predicate Func<IServiceCollection, bool> A predicate to determine if the service should be added. serviceKey object The key for the service registration. Returns IServiceCollection The updated service collection. Type Parameters TService The service type to register. AddKeyedTransientIf<TService>(IServiceCollection?, Func<IServiceCollection, bool>, object?, Func<IServiceProvider, object?, TService>) Adds a Transient service of the specified type with a factory specified in implementationFactory to the service collection if the predicate is true. public static IServiceCollection? AddKeyedTransientIf<TService>(this IServiceCollection? serviceDescriptors, Func<IServiceCollection, bool> predicate, object? serviceKey, Func<IServiceProvider, object?, TService> implementationFactory) where TService : class Parameters serviceDescriptors IServiceCollection The service collection to add the service to. predicate Func<IServiceCollection, bool> A predicate to determine if the service should be added. serviceKey object The key for the service registration. implementationFactory Func<IServiceProvider, object, TService> The factory to create the implementation. Returns IServiceCollection The updated service collection. Type Parameters TService The service type to register. AddKeyedTransientIf<TService, TImplementation>(IServiceCollection?, Func<IServiceCollection, bool>, object?) Adds a Transient service of the specified type with an implementation type to the service collection if the predicate is true. public static IServiceCollection? AddKeyedTransientIf<TService, TImplementation>(this IServiceCollection? serviceDescriptors, Func<IServiceCollection, bool> predicate, object? serviceKey) where TService : class where TImplementation : class, TService Parameters serviceDescriptors IServiceCollection The service collection to add the service to. predicate Func<IServiceCollection, bool> A predicate to determine if the service should be added. serviceKey object The key for the service registration. Returns IServiceCollection The updated service collection. Type Parameters TService The service type to register. TImplementation The implementation type to use. AddKeyedTransientIf<TService, TImplementation>(IServiceCollection?, Func<IServiceCollection, bool>, object?, Func<IServiceProvider, object?, TImplementation>) Adds a Transient service of the specified type with an implementation factory to the service collection if the predicate is true. public static IServiceCollection? AddKeyedTransientIf<TService, TImplementation>(this IServiceCollection? serviceDescriptors, Func<IServiceCollection, bool> predicate, object? serviceKey, Func<IServiceProvider, object?, TImplementation> implementationFactory) where TService : class where TImplementation : class, TService Parameters serviceDescriptors IServiceCollection The service collection to add the service to. predicate Func<IServiceCollection, bool> A predicate to determine if the service should be added. serviceKey object The key for the service registration. implementationFactory Func<IServiceProvider, object, TImplementation> The factory to create the implementation. Returns IServiceCollection The updated service collection. Type Parameters TService The service type to register. TImplementation The implementation type to use. AddScopedIf(IServiceCollection?, Func<IServiceCollection, bool>, Type) Adds a scoped service of the specified type to the service collection if the predicate is true. public static IServiceCollection? AddScopedIf(this IServiceCollection? serviceDescriptors, Func<IServiceCollection, bool> predicate, Type serviceType) Parameters serviceDescriptors IServiceCollection The service collection to add the service to. predicate Func<IServiceCollection, bool> A predicate to determine if the service should be added. serviceType Type The service type to register. Returns IServiceCollection The updated service collection. AddScopedIf(IServiceCollection?, Func<IServiceCollection, bool>, Type, Func<IServiceProvider, object>) Adds a scoped service of the specified type with an implementation factory to the service collection if the predicate is true. public static IServiceCollection? AddScopedIf(this IServiceCollection? serviceDescriptors, Func<IServiceCollection, bool> predicate, Type serviceType, Func<IServiceProvider, object> implementationFactory) Parameters serviceDescriptors IServiceCollection The service collection to add the service to. predicate Func<IServiceCollection, bool> A predicate to determine if the service should be added. serviceType Type The service type to register. implementationFactory Func<IServiceProvider, object> The factory to create the implementation. Returns IServiceCollection The updated service collection. AddScopedIf(IServiceCollection?, Func<IServiceCollection, bool>, Type, Type) Adds a scoped service of the specified type with an implementation type to the service collection if the predicate is true. public static IServiceCollection? AddScopedIf(this IServiceCollection? serviceDescriptors, Func<IServiceCollection, bool> predicate, Type serviceType, Type implementationType) Parameters serviceDescriptors IServiceCollection The service collection to add the service to. predicate Func<IServiceCollection, bool> A predicate to determine if the service should be added. serviceType Type The service type to register. implementationType Type The implementation type to use. Returns IServiceCollection The updated service collection. AddScopedIf<TService>(IServiceCollection?, Func<IServiceCollection, bool>) Adds a scoped service of the specified type to the service collection if the predicate is true. public static IServiceCollection? AddScopedIf<TService>(this IServiceCollection? serviceDescriptors, Func<IServiceCollection, bool> predicate) where TService : class Parameters serviceDescriptors IServiceCollection The service collection to add the service to. predicate Func<IServiceCollection, bool> A predicate to determine if the service should be added. Returns IServiceCollection The updated service collection. Type Parameters TService The service type to register. AddScopedIf<TService>(IServiceCollection?, Func<IServiceCollection, bool>, Func<IServiceProvider, TService>) Adds a scoped service of the specified type with a factory specified in implementationFactory to the service collection if the predicate is true. public static IServiceCollection? AddScopedIf<TService>(this IServiceCollection? serviceDescriptors, Func<IServiceCollection, bool> predicate, Func<IServiceProvider, TService> implementationFactory) where TService : class Parameters serviceDescriptors IServiceCollection The service collection to add the service to. predicate Func<IServiceCollection, bool> A predicate to determine if the service should be added. implementationFactory Func<IServiceProvider, TService> The factory to create the implementation. Returns IServiceCollection The updated service collection. Type Parameters TService The service type to register. AddScopedIf<TService, TImplementation>(IServiceCollection?, Func<IServiceCollection, bool>) Adds a scoped service of the specified type with an implementation type to the service collection if the predicate is true. public static IServiceCollection? AddScopedIf<TService, TImplementation>(this IServiceCollection? serviceDescriptors, Func<IServiceCollection, bool> predicate) where TService : class where TImplementation : class, TService Parameters serviceDescriptors IServiceCollection The service collection to add the service to. predicate Func<IServiceCollection, bool> A predicate to determine if the service should be added. Returns IServiceCollection The updated service collection. Type Parameters TService The service type to register. TImplementation The implementation type to use. AddScopedIf<TService, TImplementation>(IServiceCollection?, Func<IServiceCollection, bool>, Func<IServiceProvider, TImplementation>) Adds a scoped service of the specified type with an implementation factory to the service collection if the predicate is true. public static IServiceCollection? AddScopedIf<TService, TImplementation>(this IServiceCollection? serviceDescriptors, Func<IServiceCollection, bool> predicate, Func<IServiceProvider, TImplementation> implementationFactory) where TService : class where TImplementation : class, TService Parameters serviceDescriptors IServiceCollection The service collection to add the service to. predicate Func<IServiceCollection, bool> A predicate to determine if the service should be added. implementationFactory Func<IServiceProvider, TImplementation> The factory to create the implementation. Returns IServiceCollection The updated service collection. Type Parameters TService The service type to register. TImplementation The implementation type to use. AddSingletonIf(IServiceCollection?, Func<IServiceCollection, bool>, Type) Adds a Singleton service of the specified type to the service collection if the predicate is true. public static IServiceCollection? AddSingletonIf(this IServiceCollection? serviceDescriptors, Func<IServiceCollection, bool> predicate, Type serviceType) Parameters serviceDescriptors IServiceCollection The service collection to add the service to. predicate Func<IServiceCollection, bool> A predicate to determine if the service should be added. serviceType Type The service type to register. Returns IServiceCollection The updated service collection. AddSingletonIf(IServiceCollection?, Func<IServiceCollection, bool>, Type, Func<IServiceProvider, object>) Adds a Singleton service of the specified type with an implementation factory to the service collection if the predicate is true. public static IServiceCollection? AddSingletonIf(this IServiceCollection? serviceDescriptors, Func<IServiceCollection, bool> predicate, Type serviceType, Func<IServiceProvider, object> implementationFactory) Parameters serviceDescriptors IServiceCollection The service collection to add the service to. predicate Func<IServiceCollection, bool> A predicate to determine if the service should be added. serviceType Type The service type to register. implementationFactory Func<IServiceProvider, object> The factory to create the implementation. Returns IServiceCollection The updated service collection. AddSingletonIf(IServiceCollection?, Func<IServiceCollection, bool>, Type, Type) Adds a Singleton service of the specified type with an implementation type to the service collection if the predicate is true. public static IServiceCollection? AddSingletonIf(this IServiceCollection? serviceDescriptors, Func<IServiceCollection, bool> predicate, Type serviceType, Type implementationType) Parameters serviceDescriptors IServiceCollection The service collection to add the service to. predicate Func<IServiceCollection, bool> A predicate to determine if the service should be added. serviceType Type The service type to register. implementationType Type The implementation type to use. Returns IServiceCollection The updated service collection. AddSingletonIf<TService>(IServiceCollection?, Func<IServiceCollection, bool>) Adds a Singleton service of the specified type to the service collection if the predicate is true. public static IServiceCollection? AddSingletonIf<TService>(this IServiceCollection? serviceDescriptors, Func<IServiceCollection, bool> predicate) where TService : class Parameters serviceDescriptors IServiceCollection The service collection to add the service to. predicate Func<IServiceCollection, bool> A predicate to determine if the service should be added. Returns IServiceCollection The updated service collection. Type Parameters TService The service type to register. AddSingletonIf<TService>(IServiceCollection?, Func<IServiceCollection, bool>, Func<IServiceProvider, TService>) Adds a Singleton service of the specified type with a factory specified in implementationFactory to the service collection if the predicate is true. public static IServiceCollection? AddSingletonIf<TService>(this IServiceCollection? serviceDescriptors, Func<IServiceCollection, bool> predicate, Func<IServiceProvider, TService> implementationFactory) where TService : class Parameters serviceDescriptors IServiceCollection The service collection to add the service to. predicate Func<IServiceCollection, bool> A predicate to determine if the service should be added. implementationFactory Func<IServiceProvider, TService> The factory to create the implementation. Returns IServiceCollection The updated service collection. Type Parameters TService The service type to register. AddSingletonIf<TService, TImplementation>(IServiceCollection?, Func<IServiceCollection, bool>) Adds a Singleton service of the specified type with an implementation type to the service collection if the predicate is true. public static IServiceCollection? AddSingletonIf<TService, TImplementation>(this IServiceCollection? serviceDescriptors, Func<IServiceCollection, bool> predicate) where TService : class where TImplementation : class, TService Parameters serviceDescriptors IServiceCollection The service collection to add the service to. predicate Func<IServiceCollection, bool> A predicate to determine if the service should be added. Returns IServiceCollection The updated service collection. Type Parameters TService The service type to register. TImplementation The implementation type to use. AddSingletonIf<TService, TImplementation>(IServiceCollection?, Func<IServiceCollection, bool>, Func<IServiceProvider, TImplementation>) Adds a Singleton service of the specified type with an implementation factory to the service collection if the predicate is true. public static IServiceCollection? AddSingletonIf<TService, TImplementation>(this IServiceCollection? serviceDescriptors, Func<IServiceCollection, bool> predicate, Func<IServiceProvider, TImplementation> implementationFactory) where TService : class where TImplementation : class, TService Parameters serviceDescriptors IServiceCollection The service collection to add the service to. predicate Func<IServiceCollection, bool> A predicate to determine if the service should be added. implementationFactory Func<IServiceProvider, TImplementation> The factory to create the implementation. Returns IServiceCollection The updated service collection. Type Parameters TService The service type to register. TImplementation The implementation type to use. AddTransientIf(IServiceCollection?, Func<IServiceCollection, bool>, Type) Adds a Transient service of the specified type to the service collection if the predicate is true. public static IServiceCollection? AddTransientIf(this IServiceCollection? serviceDescriptors, Func<IServiceCollection, bool> predicate, Type serviceType) Parameters serviceDescriptors IServiceCollection The service collection to add the service to. predicate Func<IServiceCollection, bool> A predicate to determine if the service should be added. serviceType Type The service type to register. Returns IServiceCollection The updated service collection. AddTransientIf(IServiceCollection?, Func<IServiceCollection, bool>, Type, Func<IServiceProvider, object>) Adds a Transient service of the specified type with an implementation factory to the service collection if the predicate is true. public static IServiceCollection? AddTransientIf(this IServiceCollection? serviceDescriptors, Func<IServiceCollection, bool> predicate, Type serviceType, Func<IServiceProvider, object> implementationFactory) Parameters serviceDescriptors IServiceCollection The service collection to add the service to. predicate Func<IServiceCollection, bool> A predicate to determine if the service should be added. serviceType Type The service type to register. implementationFactory Func<IServiceProvider, object> The factory to create the implementation. Returns IServiceCollection The updated service collection. AddTransientIf(IServiceCollection?, Func<IServiceCollection, bool>, Type, Type) Adds a Transient service of the specified type with an implementation type to the service collection if the predicate is true. public static IServiceCollection? AddTransientIf(this IServiceCollection? serviceDescriptors, Func<IServiceCollection, bool> predicate, Type serviceType, Type implementationType) Parameters serviceDescriptors IServiceCollection The service collection to add the service to. predicate Func<IServiceCollection, bool> A predicate to determine if the service should be added. serviceType Type The service type to register. implementationType Type The implementation type to use. Returns IServiceCollection The updated service collection. AddTransientIf<TService>(IServiceCollection?, Func<IServiceCollection, bool>) Adds a Transient service of the specified type to the service collection if the predicate is true. public static IServiceCollection? AddTransientIf<TService>(this IServiceCollection? serviceDescriptors, Func<IServiceCollection, bool> predicate) where TService : class Parameters serviceDescriptors IServiceCollection The service collection to add the service to. predicate Func<IServiceCollection, bool> A predicate to determine if the service should be added. Returns IServiceCollection The updated service collection. Type Parameters TService The service type to register. AddTransientIf<TService>(IServiceCollection?, Func<IServiceCollection, bool>, Func<IServiceProvider, TService>) Adds a Transient service of the specified type with a factory specified in implementationFactory to the service collection if the predicate is true. public static IServiceCollection? AddTransientIf<TService>(this IServiceCollection? serviceDescriptors, Func<IServiceCollection, bool> predicate, Func<IServiceProvider, TService> implementationFactory) where TService : class Parameters serviceDescriptors IServiceCollection The service collection to add the service to. predicate Func<IServiceCollection, bool> A predicate to determine if the service should be added. implementationFactory Func<IServiceProvider, TService> The factory to create the implementation. Returns IServiceCollection The updated service collection. Type Parameters TService The service type to register. AddTransientIf<TService, TImplementation>(IServiceCollection?, Func<IServiceCollection, bool>) Adds a Transient service of the specified type with an implementation type to the service collection if the predicate is true. public static IServiceCollection? AddTransientIf<TService, TImplementation>(this IServiceCollection? serviceDescriptors, Func<IServiceCollection, bool> predicate) where TService : class where TImplementation : class, TService Parameters serviceDescriptors IServiceCollection The service collection to add the service to. predicate Func<IServiceCollection, bool> A predicate to determine if the service should be added. Returns IServiceCollection The updated service collection. Type Parameters TService The service type to register. TImplementation The implementation type to use. AddTransientIf<TService, TImplementation>(IServiceCollection?, Func<IServiceCollection, bool>, Func<IServiceProvider, TImplementation>) Adds a Transient service of the specified type with an implementation factory to the service collection if the predicate is true. public static IServiceCollection? AddTransientIf<TService, TImplementation>(this IServiceCollection? serviceDescriptors, Func<IServiceCollection, bool> predicate, Func<IServiceProvider, TImplementation> implementationFactory) where TService : class where TImplementation : class, TService Parameters serviceDescriptors IServiceCollection The service collection to add the service to. predicate Func<IServiceCollection, bool> A predicate to determine if the service should be added. implementationFactory Func<IServiceProvider, TImplementation> The factory to create the implementation. Returns IServiceCollection The updated service collection. Type Parameters TService The service type to register. TImplementation The implementation type to use. Exists(IServiceCollection?, Type) Determines if the specified service type exists in the service collection. public static bool Exists(this IServiceCollection? serviceDescriptors, Type serviceType) Parameters serviceDescriptors IServiceCollection The service descriptors. serviceType Type The type of the service. Returns bool true if the service type exists; otherwise, false. Exists(IServiceCollection?, Type, object?) Determines if the specified keyed service type exists in the service collection. public static bool Exists(this IServiceCollection? serviceDescriptors, Type serviceType, object? serviceKey) Parameters serviceDescriptors IServiceCollection The service descriptors. serviceType Type The type of the service. serviceKey object The service key. Returns bool true if the keyed service type exists; otherwise, false. Exists(IServiceCollection?, Type, Type) Determines if the specified service and implementation types exist in the service collection. public static bool Exists(this IServiceCollection? serviceDescriptors, Type serviceType, Type implementationType) Parameters serviceDescriptors IServiceCollection The service descriptors. serviceType Type The type of the service. implementationType Type The type of the implementation. Returns bool true if the service and implementation types exist; otherwise, false. Exists<TService>(IServiceCollection?) Determines if the specified service type exists in the service collection. public static bool Exists<TService>(this IServiceCollection? serviceDescriptors) Parameters serviceDescriptors IServiceCollection The service descriptors. Returns bool true if the service type exists; otherwise, false. Type Parameters TService The type of the service. Exists<TService>(IServiceCollection?, object?) Determines if the specified keyed service type exists in the service collection. public static bool Exists<TService>(this IServiceCollection? serviceDescriptors, object? serviceKey) Parameters serviceDescriptors IServiceCollection The service descriptors. serviceKey object The service key. Returns bool true if the keyed service type exists; otherwise, false. Type Parameters TService The type of the service. Exists<TService, TImplementation>(IServiceCollection?) Determines if the specified service and implementation types exist in the service collection. public static bool Exists<TService, TImplementation>(this IServiceCollection? serviceDescriptors) where TService : class where TImplementation : class, TService Parameters serviceDescriptors IServiceCollection The service descriptors. Returns bool true if the service and implementation types exist; otherwise, false. Type Parameters TService The type of the service. TImplementation The type of the implementation. TryAddAllScoped(IServiceCollection?, Type) Attempts to add all available types that are assignable to the specified type as scoped services to the provided IServiceCollection. public static IServiceCollection? TryAddAllScoped(this IServiceCollection? serviceDescriptors, Type registerType) Parameters serviceDescriptors IServiceCollection The IServiceCollection to which the services will be added. Cannot be null. registerType Type The type to register as a scoped service. This can be a concrete type or an interface. If it is a generic type definition, it will be registered as itself. Returns IServiceCollection The updated IServiceCollection with the added scoped services, or null if serviceDescriptors is null. Remarks This method scans the available types in the application's configuration and registers all types that are assignable to registerType as scoped services. If registerType is a generic type definition, it will also be registered as itself. TryAddAllScoped<T>(IServiceCollection?) Attempts to register all implementations of the specified service type as scoped services in the service collection. public static IServiceCollection? TryAddAllScoped<T>(this IServiceCollection? serviceDescriptors) Parameters serviceDescriptors IServiceCollection The service collection to which the scoped services will be added. Returns IServiceCollection The updated IServiceCollection if the operation succeeds; otherwise, null if serviceDescriptors is null. Type Parameters T The service type to register implementations for. Remarks This method registers all implementations of the specified service type T as scoped services. If serviceDescriptors is null, no services are added, and null is returned. TryAddAllSingleton(IServiceCollection?, Type) Attempts to add all available types that are assignable to the specified type as Singleton services to the provided IServiceCollection. public static IServiceCollection? TryAddAllSingleton(this IServiceCollection? serviceDescriptors, Type registerType) Parameters serviceDescriptors IServiceCollection The IServiceCollection to which the services will be added. Cannot be null. registerType Type The type to register as a Singleton service. This can be a concrete type or an interface. If it is a generic type definition, it will be registered as itself. Returns IServiceCollection The updated IServiceCollection with the added Singleton services, or null if serviceDescriptors is null. Remarks This method scans the available types in the application's configuration and registers all types that are assignable to registerType as Singleton services. If registerType is a generic type definition, it will also be registered as itself. TryAddAllSingleton<T>(IServiceCollection?) Attempts to register all implementations of the specified service type as Singleton services in the service collection. public static IServiceCollection? TryAddAllSingleton<T>(this IServiceCollection? serviceDescriptors) Parameters serviceDescriptors IServiceCollection The service collection to which the Singleton services will be added. Returns IServiceCollection The updated IServiceCollection if the operation succeeds; otherwise, null if serviceDescriptors is null. Type Parameters T The service type to register implementations for. Remarks This method registers all implementations of the specified service type T as Singleton services. If serviceDescriptors is null, no services are added, and null is returned. TryAddAllTransient(IServiceCollection?, Type) Attempts to add all available types that are assignable to the specified type as Transient services to the provided IServiceCollection. public static IServiceCollection? TryAddAllTransient(this IServiceCollection? serviceDescriptors, Type registerType) Parameters serviceDescriptors IServiceCollection The IServiceCollection to which the services will be added. Cannot be null. registerType Type The type to register as a Transient service. This can be a concrete type or an interface. If it is a generic type definition, it will be registered as itself. Returns IServiceCollection The updated IServiceCollection with the added Transient services, or null if serviceDescriptors is null. Remarks This method scans the available types in the application's configuration and registers all types that are assignable to registerType as Transient services. If registerType is a generic type definition, it will also be registered as itself. TryAddAllTransient<T>(IServiceCollection?) Attempts to register all implementations of the specified service type as Transient services in the service collection. public static IServiceCollection? TryAddAllTransient<T>(this IServiceCollection? serviceDescriptors) Parameters serviceDescriptors IServiceCollection The service collection to which the Transient services will be added. Returns IServiceCollection The updated IServiceCollection if the operation succeeds; otherwise, null if serviceDescriptors is null. Type Parameters T The service type to register implementations for. Remarks This method registers all implementations of the specified service type T as Transient services. If serviceDescriptors is null, no services are added, and null is returned."
  },
  "api/Microsoft.Extensions.DependencyInjection.html": {
    "href": "api/Microsoft.Extensions.DependencyInjection.html",
    "title": "Namespace Microsoft.Extensions.DependencyInjection | Canister API Reference",
    "summary": "Namespace Microsoft.Extensions.DependencyInjection Classes ServiceCollectionDecoratorExtensions Provides extension methods for decorating registered services. ServiceCollectionDiagnosticsExtensions Provides diagnostic and debugging extension methods for IServiceCollection. ServiceCollectionExtensions Extension methods for IServiceCollection to check for the existence of services."
  },
  "api/index.html": {
    "href": "api/index.html",
    "title": "Welcome | Canister API Reference",
    "summary": "Welcome Welcome to the API browser."
  },
  "articles/intro.html": {
    "href": "articles/intro.html",
    "title": "Code | Canister API Reference",
    "summary": "Code using Canister.Interfaces; using Canister.IoC.Attributes; using Microsoft.Extensions.DependencyInjection; using Microsoft.Extensions.Logging; namespace Canister.IoC.Example { // Interfaces and classes used in the examples internal interface IMyService { string Name { get; } } [RegisterAll(ServiceLifetime.Singleton)] internal interface IRegisteredInterface; // Example 1: Basic module registration and resolution internal static class Example1 { public static void Run() { Console.WriteLine(\"--- Example 1: Basic module registration and resolution ---\"); var services = new ServiceCollection(); services.AddCanisterModules(); services.AddAllSingleton<IMyService>(); var provider = services.BuildServiceProvider(); var registered = provider.GetServices<IRegisteredInterface>(); Console.WriteLine($\"Number of registered classes found: {registered.Count()}\"); var serviceClasses = provider.GetServices<IMyService>(); Console.WriteLine($\"Number of services found: {serviceClasses.Count()}\"); foreach (var svc in serviceClasses) Console.WriteLine(svc.Name); var simple = provider.GetService<SimpleExampleClass>(); Console.WriteLine(simple?.Name); } } // Example 2: Using UseLogger with Canister configuration internal static class Example2 { public static void Run() { Console.WriteLine(\"--- Example 2: Using UseLogger with Canister configuration ---\"); using var loggerFactory = LoggerFactory.Create(builder => { builder.AddConsole(); builder.SetMinimumLevel(LogLevel.Information); }); var logger = loggerFactory.CreateLogger(\"Canister.IoC.Example\"); var services = new ServiceCollection(); services.AddCanisterModules(configure => configure.UseLogger(logger, LogLevel.Information)); services.AddAllSingleton<IMyService>(); var provider = services.BuildServiceProvider(); var registered = provider.GetServices<IRegisteredInterface>(); Console.WriteLine($\"Number of registered classes found: {registered.Count()}\"); var serviceClasses = provider.GetServices<IMyService>(); Console.WriteLine($\"Number of services found: {serviceClasses.Count()}\"); foreach (var svc in serviceClasses) Console.WriteLine(svc.Name); var simple = provider.GetService<SimpleExampleClass>(); Console.WriteLine(simple?.Name); } } // Example 3: Using RegisterAll* without Canister configuration internal static class Example3 { public static void Run() { Console.WriteLine(\"--- Example 3: Using RegisterAll* without Canister configuration ---\"); var services = new ServiceCollection(); services.AddAllScoped<IRegisteredInterface>(); var provider = services.BuildServiceProvider(); var registered = provider.GetServices<IRegisteredInterface>(); Console.WriteLine($\"Number of registered classes found: {registered.Count()}\"); foreach (var reg in registered) Console.WriteLine(reg.GetType().Name); } } internal static class Program { private static void Main(string[] args) { while (true) { Console.WriteLine(\"Select an example to run:\"); Console.WriteLine(\"1. Basic module registration and resolution\"); Console.WriteLine(\"2. Using UseLogger with Canister configuration\"); Console.WriteLine(\"3. Using RegisterAll* without Canister configuration\"); Console.WriteLine(\"Q. Quit\"); Console.Write(\"Enter your choice: \"); var input = Console.ReadLine(); if (string.Equals(input, \"q\", StringComparison.OrdinalIgnoreCase)) break; switch (input) { case \"1\": Example1.Run(); break; case \"2\": Example2.Run(); break; case \"3\": Example3.Run(); break; default: Console.WriteLine(\"Invalid selection.\\n\"); break; } Console.WriteLine(); } } } internal class ExampleService1 : IMyService { public string Name => \"ExampleService1\"; } internal class ExampleService2 : IMyService { public string Name => \"ExampleService2\"; } internal class MyModule : IModule { public int Order { get; } public void Load(IServiceCollection serviceDescriptors) => serviceDescriptors.AddTransient<SimpleExampleClass>(); } internal class RegisteredClass1 : IRegisteredInterface; internal class RegisteredClass2 : IRegisteredInterface; internal class SimpleExampleClass { public string Name => \"SimpleExampleClass\"; } } Output Select an example to run: 1. Basic module registration and resolution 2. Using UseLogger with Canister configuration Q. Quit Enter your choice: 1 --- Example 1: Basic module registration and resolution --- Number of registered classes found: 2 Number of services found: 2 ExampleService1 ExampleService2 SimpleExampleClass Select an example to run: 1. Basic module registration and resolution 2. Using UseLogger with Canister configuration Q. Quit Enter your choice: 2 --- Example 2: Using UseLogger with Canister configuration --- info: Canister.IoC.Example[0] Default assemblies added: Canister.IoC.Example, Canister.IoC info: Canister.IoC.Example[0] Assembly loaded: Canister.IoC info: Canister.IoC.Example[0] Assembly loaded: Canister.IoC.Example info: Canister.IoC.Example[0] Assembly loaded: Fast.Activator info: Canister.IoC.Example[0] Assembly loaded: Microsoft.Extensions.Configuration.Abstractions info: Canister.IoC.Example[0] Assembly loaded: Microsoft.Extensions.Configuration.Binder info: Canister.IoC.Example[0] Assembly loaded: Microsoft.Extensions.Configuration info: Canister.IoC.Example[0] Assembly loaded: Microsoft.Extensions.DependencyInjection.Abstractions info: Canister.IoC.Example[0] Assembly loaded: Microsoft.Extensions.DependencyInjection info: Canister.IoC.Example[0] Assembly loaded: Microsoft.Extensions.Logging.Abstractions info: Canister.IoC.Example[0] Assembly loaded: Microsoft.Extensions.Logging.Configuration info: Canister.IoC.Example[0] Assembly loaded: Microsoft.Extensions.Logging.Console info: Canister.IoC.Example[0] Assembly loaded: Microsoft.Extensions.Logging info: Canister.IoC.Example[0] Assembly loaded: Microsoft.Extensions.Options.ConfigurationExtensions info: Canister.IoC.Example[0] Assembly loaded: Microsoft.Extensions.Options info: Canister.IoC.Example[0] Assembly loaded: Microsoft.Extensions.Primitives info: Canister.IoC.Example[0] Assembly loaded: System.Diagnostics.DiagnosticSource info: Canister.IoC.Example[0] Assembly loaded: System.IO.Pipelines info: Canister.IoC.Example[0] Assembly loaded: System.Text.Encodings.Web info: Canister.IoC.Example[0] Assembly loaded: System.Text.Json info: Canister.IoC.Example[0] Adding transient service: Canister.IoC.Example.MyModule as Canister.Interfaces.IModule info: Canister.IoC.Example[0] Adding transient service: Canister.IoC.Modules.DefaultModule as Canister.Interfaces.IModule info: Canister.IoC.Example[0] Module loading: MyModule info: Canister.IoC.Example[0] Module successfully loaded: MyModule info: Canister.IoC.Example[0] Module loading: DefaultModule info: Canister.IoC.Example[0] Module successfully loaded: DefaultModule info: Canister.IoC.Example[0] Adding singleton service: Canister.IoC.Example.RegisteredClass1 as Canister.IoC.Example.IRegisteredInterface info: Canister.IoC.Example[0] Adding singleton service: Canister.IoC.Example.RegisteredClass2 as Canister.IoC.Example.IRegisteredInterface Number of registered classes found: 2 Number of services found: 2 ExampleService1 ExampleService2 SimpleExampleClass Select an example to run: 1. Basic module registration and resolution 2. Using UseLogger with Canister configuration 3. Using RegisterAll* without Canister configuration Q. Quit Enter your choice: 3 --- Example 3: Using RegisterAll* without Canister configuration --- Number of registered classes found: 2 RegisteredClass1 RegisteredClass2"
  },
  "index.html": {
    "href": "index.html",
    "title": "Canister | Canister API Reference",
    "summary": "Canister Canister is one of the easiest ways to get IoC configuration under control. No longer do you have to search for that one class that you forgot to register. Instead use Canister to handle discovery and registration for you using a simple interface. Table of Contents Quick Start Basic Usage Modules Attributes Canister Extension Methods Working With Other IoC Containers Using Canister in Your Library Installation Build Process Quick Start using Microsoft.Extensions.DependencyInjection; var services = new ServiceCollection(); services.AddCanisterModules(); var provider = services.BuildServiceProvider(); For a more detailed example, you can check out the Canister Example which demonstrates how to use Canister in a couple simple scenarios. Basic Usage The system has a fairly simple interface and only a couple of functions that need explaining. The first is setup: public void ConfigureServices(IServiceCollection services) { ... services.AddCanisterModules(); } AddCanisterModules will automatically scan assemblies for modules and load them accordingly. Or if you're doing a desktop app: var Services = new ServiceCollection().AddCanisterModules(); Note that if you like, you can control which assemblies are searched: public void ConfigureServices(IServiceCollection services) { ... services.AddCanisterModules(configure => configure.AddAssembly(typeof(Startup).Assembly)); } Note: For security reasons, it's recommended to explicitly specify which assemblies to scan. By default, Canister will search all assemblies found in the entry assembly's top-level directory. It is also possible to add logging to the system while configuring it. This is useful for debugging purposes or to get insights into the registration process. You can do this by passing an ILogger instance to the UseLogger method along with a default log level: public void ConfigureServices(IServiceCollection services, ILogger logger) { ... services.AddCanisterModules().UseLogger(logger, LogLevel.Information); } Modules Canister uses the concept of modules to wire things up, but is not a requirement. This allows you to place registration code in libraries that your system is using instead of worrying about it in every application. Simply add your library and Canister will automatically wire it up for you. In order to do this, under Canister.Interfaces there is the IModule interface. This interface, when implemented, has two items in it. The first is a property called Order. This determines the order that the modules are loaded in. The second is a function called Load: public class TestModule : IModule { public int Order => 1; public void Load(IServiceCollection bootstrapper) { bootstrapper.AddAllTransient<IMyInterface>(); bootstrapper.AddTransient<MyType>(); } } The module above is loaded automatically by the system and will have the Load function called at initialization time. At this point you should be able to resolve and register classes using the bootstrapper parameter. The service collection also has a couple of extra extension methods: AddAllTransient, AddAllScoped, AddAllSingleton: bootstrapper.AddAllTransient<IMyInterface>(); The AddAllxxxx functions will find everything that implements a class or interface in the Assemblies that you tell it to look in and will register them with the service collection. Attributes Canister also allows for attributes to be used to control registration. There are two attributes that the system uses: RegisterAttribute - This attribute is used to control how a class is registered. It will register the class as all interfaces that it implements as well as the class itself. The attribute takes the life time of the registration as a parameter. If no parameter is given, the registration will be transient. It also can take a service key as well. [Register(LifeTime.Singleton)] public class MyType : IMyInterface { } RegisterAllAttribute - This attribute is used to control how an interface is registered. It will register all classes that implement the interface similar to the AddAllxxxx functions. The attribute takes the life time of the registration as a parameter. If no parameter is given, the registration will be transient. [RegisterAll(LifeTime.Singleton)] public interface IMyInterface { } Canister Extension Methods Canister provides a set of extension methods to streamline your IoC (Inversion of Control) container registration code. These methods offer convenient ways to conditionally register services based on certain criteria, enhancing the flexibility of your application's dependency injection setup. Note that these can be used even if you are not using the Canister modules. 1. AddTransientIf() The AddTransientIf method registers a service as transient only if a specified condition is met. This is useful when you want to dynamically determine whether a service should be transient or not. services.AddTransientIf<IMyService, MyService>(services => condition); 2. AddScopedIf() Similar to AddTransientIf, AddScopedIf registers a service as scoped based on a given condition. services.AddScopedIf<IMyScopedService, MyScopedService>(services => condition); 3. AddSingletonIf() The AddSingletonIf method registers a service as a singleton if the specified condition holds true. services.AddSingletonIf<IMySingletonService, MySingletonService>(services => condition); 4. AddKeyedTransientIf(), AddKeyedScopedIf(), AddKeyedSingletonIf() These methods follow the same pattern as their non-keyed counterparts but additionally allow you to register services with a specified key. services.AddKeyedTransientIf<IService>(key, implementationType, (services, key) => condition); 5. Exists() The Exists method checks whether a service with a specific type and, optionally, a key, has already been registered. This can be helpful in avoiding duplicate registrations or finding issues with your environment before starting the application. if (!services.Exists<IMyService>()) { services.AddTransient<IMyService, MyService>(); } 6. AddAllTransient(), AddAllScoped(), AddAllSingleton() These methods allow you to register all implementations of a given interface or class as transient, scoped, or singleton services, respectively. They are particularly useful for bulk registrations. services.AddAllTransient<IMyService>(); services.AddAllScoped<IMyScopedService>(); services.AddAllSingleton<IMySingletonService>(); 7. TryAddAllTransient(), TryAddAllScoped(), TryAddAllSingleton() These methods attempt to register all implementations of a given interface or class as transient, scoped, or singleton services, but only if they have not already been registered. This is useful for ensuring that you do not accidentally override existing registrations. services.TryAddAllTransient<IMyService>(); services.TryAddAllScoped<IMyScopedService>(); services.TryAddAllSingleton<IMySingletonService>(); 8. Decorate() The Decorate method allows you to wrap an existing service with a decorator. This is useful for adding additional behavior to a service without modifying its original implementation. services.Decorate<IMyService, MyServiceDecorator>(); 9. AddCanisterModules() The AddCanisterModules method is used to automatically discover and register modules that implement the IModule interface. This method scans the specified assemblies for modules and loads them, allowing you to organize your service registrations in a modular way. services.AddCanisterModules(config => { // Optionally specify which assemblies to scan config.AddAssembly(typeof(MyModule).Assembly) .UseLogger(logger, LogLevel.Information); }); 10. GetRegistrationsSummary() The GetRegistrationsSummary method provides a summary of all registered services in the IoC container. This can be useful for debugging and understanding what services are available in your application. var summary = services.GetRegistrationsSummary(); logger.LogInformation(\"Service Registrations: {Summary}\", summary); Usage Example Here's an example of how you might use these methods: IHostEnvironment? environment; // Conditionally register a transient service if in development environment. services.AddTransientIf<IMyService, MyDebugService>(_ => environment.IsDevelopment()); // However if you're in production, add a different implementation. services.AddTransientIf<IMyService, MyProductionService>(_ => environment.IsProduction()); // Check if a keyed service is missing and log a warning if so. if (!services.Exists<IService>(key)) { logger.LogWarning(\"Service {Service} is missing\", key); } These methods empower you to create more dynamic and adaptive dependency injection configurations tailored to your application's requirements. Working With Other IoC Containers While the library assumes you are using the built in ServiceCollection, it is possible to work with IoC containers. All that is required is that it implements the IServiceCollection interface. Using Canister in Your library If you wish to use Canister in your library, it is recommended that you build an extension method off of the ICanisterConfiguration interface that will allow you to register your needed assemblies for the user to make the experience a bit simpler when they want to control configuration themselves. Installation The library is available via Nuget with the package name \"Canister.IoC\". To install it run the following command in the Package Manager Console: dotnet add package Canister.IoC Build Process In order to build the library you may require the following: Visual Studio 2022 Other than that, just clone the project and you should be able to load the solution and build without too much effort. License This project is licensed under the Apache License 2.0 - see the LICENSE file for details. Contributing If you would like to contribute to the project, please fork the repository and submit a pull request. Contributions are welcome, and we appreciate any help in improving the library. Please refer to the Contributing Guide for more details on how to contribute."
  }
}